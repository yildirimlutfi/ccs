/* XDCtools Header files */
#include <xdc/std.h>
#include <xdc/runtime/Assert.h>
#include <xdc/runtime/Error.h>
#include <xdc/runtime/System.h>
/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/knl/Semaphore.h>
#include <ti/sysbios/knl/Clock.h>
/* TI-RTOS Header files */
#include <ti/drivers/PIN.h>
#include <ti/drivers/power/PowerCC26XX.h>
/* Board Header files */
#include "Board.h"
/* EasyLink API Header files */
#include "easylink/EasyLink.h"
/* Application header files */
#include "smartrf_settings/smartrf_settings.h"
/* Runtime Library Header Files */
#include <stdlib.h>
#include <string.h>
/* Driverlib Header files */
#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(driverlib/trng.h)
/*Timer Header Files */
#include <ti/sysbios/knl/Clock.h>
#include <ti/sysbios/hal/Seconds.h>

 /* Application LED pin configuration table:
 *   - All LEDs board LEDs are off.  */
PIN_Config pinTable[] = {
    Board_PIN_LED1 | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MAX,
    Board_PIN_LED2 | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MAX,
    PIN_TERMINATE };
PIN_Handle ledPinHandle;

/*Defination for taskTimer */
Clock_Params clockParamsTimer;
Clock_Handle handleTaskTimer;
Error_Block ebTaskTimer;


/*Defination for semaphore*/
Semaphore_Struct structSemaphore;
Semaphore_Handle handleSemaphore;
Task_Struct taskStructSsemaphore1,taskStructSsemaphore2;
Error_Block errorBlockSemaphore;
Task_Params taskParamsSemaphore;
Semaphore_Params paramsSemaphore;



int counter1=0,counter2=0,counter3=0,counter4=0;

void fonksiyonSemaphore1(UArg uarg1, UArg uarg2)
{

    handleSemaphore= Semaphore_create(1, &paramsSemaphore, &errorBlockSemaphore);
    Semaphore_pend(handleSemaphore,BIOS_WAIT_FOREVER);
    counter2++;
    Semaphore_post(handleSemaphore);
    Task_sleep(1000);
    PIN_setOutputValue(ledPinHandle, Board_PIN_LED1,!PIN_getOutputValue(Board_PIN_LED1));
}

void fonksiyonSemaphore2(UArg uarg1, UArg uarg2)
{
    handleSemaphore= Semaphore_create(1, &paramsSemaphore, &errorBlockSemaphore);
    Semaphore_pend(handleSemaphore,BIOS_WAIT_FOREVER);
    counter3++;
    Semaphore_post(handleSemaphore);
    Task_sleep(1000);
    PIN_setOutputValue(ledPinHandle, Board_PIN_LED2,!PIN_getOutputValue(Board_PIN_LED2));
}

void taskTimer(UArg arg1)//tick=1s
{
    Task_yield();//taskYIELD() is used to request a context switch to another task.taskThread1 ile taskThread2 arasi gecis icin kullanildi
    counter1++;
}


void main()
{
    Error_init(&ebTaskTimer);//timer fonksiyonu olusturuldu
    Clock_Params_init(&clockParamsTimer);
    clockParamsTimer.period = 100000;//1us*100000=1 saniye
    clockParamsTimer.startFlag = TRUE;
    handleTaskTimer=Clock_create(taskTimer, 100, &clockParamsTimer, &ebTaskTimer);
    if(handleTaskTimer==NULL)
    {
     System_abort("taskTimer create failed");
    }

    Board_initGeneral();

    Task_Params_init(&taskParamsSemaphore);
    taskParamsSemaphore.stackSize=512;
    taskParamsSemaphore.priority=1;
    Task_construct(&taskStructSsemaphore1,(Task_FuncPtr)fonksiyonSemaphore1,&taskParamsSemaphore,&errorBlockSemaphore);

    taskParamsSemaphore.stackSize=512;
    taskParamsSemaphore.priority=2;
    Task_construct(&taskStructSsemaphore2,(Task_FuncPtr)fonksiyonSemaphore2,&taskParamsSemaphore,&errorBlockSemaphore);


    paramsSemaphore.mode= SemaphoreP_Mode_COUNTING;


    Semaphore_Params_init(&paramsSemaphore);
    Semaphore_construct(&structSemaphore,1,&paramsSemaphore);
    handleSemaphore=Semaphore_handle(&structSemaphore);

    BIOS_start();
}
